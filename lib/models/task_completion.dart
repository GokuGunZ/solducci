/// Task completion history model
/// Used to track when recurring tasks are completed.
///
/// For recurring tasks:
/// - When completed, an entry is added to task_completions history
/// - The task itself is reset to pending (not deleted)
/// - This maintains a history of all completions for analytics/tracking
///
/// For non-recurring tasks:
/// - No completion history is created (task just marked as completed)
class TaskCompletion {
  final String id;
  final String taskId;
  final DateTime completedAt;
  String? notes; // Optional notes about the completion

  TaskCompletion({
    required this.id,
    required this.taskId,
    required this.completedAt,
    this.notes,
  });

  /// Create TaskCompletion from Supabase map
  factory TaskCompletion.fromMap(Map<String, dynamic> map) {
    return TaskCompletion(
      id: map['id'] as String,
      taskId: map['task_id'] as String,
      completedAt: DateTime.parse(map['completed_at'] as String),
      notes: map['notes'] as String?,
    );
  }

  /// Convert TaskCompletion to map for Supabase
  Map<String, dynamic> toMap() {
    final map = <String, dynamic>{
      'task_id': taskId,
      'completed_at': completedAt.toIso8601String(),
      'notes': notes,
    };

    // Only include id for updates (rarely needed for completions)
    if (id.isNotEmpty && id != '00000000-0000-0000-0000-000000000000') {
      map['id'] = id;
    }

    return map;
  }

  /// Convert to map for insert (without id)
  Map<String, dynamic> toInsertMap() {
    return {
      'task_id': taskId,
      'completed_at': completedAt.toIso8601String(),
      'notes': notes,
    };
  }

  /// Create a new completion entry
  factory TaskCompletion.create({
    required String taskId,
    DateTime? completedAt,
    String? notes,
  }) {
    return TaskCompletion(
      id: '', // Will be generated by Supabase
      taskId: taskId,
      completedAt: completedAt ?? DateTime.now(),
      notes: notes,
    );
  }

  /// Create a copy with modified fields
  TaskCompletion copyWith({
    String? notes,
  }) {
    return TaskCompletion(
      id: id,
      taskId: taskId,
      completedAt: completedAt,
      notes: notes ?? this.notes,
    );
  }

  @override
  String toString() {
    return 'TaskCompletion(id: $id, taskId: $taskId, completedAt: $completedAt)';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is TaskCompletion && other.id == id;
  }

  @override
  int get hashCode => id.hashCode;
}
